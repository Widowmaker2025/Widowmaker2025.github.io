<!DOCTYPE html>
<html lang="en">

<head>
    <meta name="referrer" content="no-referrer"/>
    <title>Git版本管理 | Widomaker</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://widowmaker2025.github.io/style.css">
    <link rel="stylesheet" href="https://widowmaker2025.github.io/color/blue.css">

        <link rel="stylesheet" href="https://widowmaker2025.github.io/color/background_green.css">
    
    <link rel="stylesheet" href="https://widowmaker2025.github.io/font-hack.css">

    <meta name="description" content="">

    <meta property="og:description" content="">
    <meta property="og:title" content="Git版本管理 | Widomaker">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://widowmaker2025.github.io/gitban-ben-guan-li-zhuan-zai/">

    <meta property="og:image" content="https://widowmaker2025.github.io/static/ocean.jpg">
    <meta name="twitter:image" content="https://widowmaker2025.github.io/static/ocean.jpg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="">
    <meta name="twitter:title" content="Git版本管理 | Widomaker">
    <meta property="twitter:domain" content="widowmaker2025.github.io">
    <meta property="twitter:url" content="https://widowmaker2025.github.io/gitban-ben-guan-li-zhuan-zai/">

    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/viewerjs/1.11.6/viewer.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/AlertifyJS/1.13.1/css/alertify.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/AlertifyJS/1.13.1/css/themes/default.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script>console.log=()=>{}</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://unpkg.com/topbar@3.0.0/topbar.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/viewerjs/1.11.6/viewer.min.js"crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/AlertifyJS/1.13.1/alertify.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.31.0/tocbot.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src='https://widowmaker2025.github.io/js/main.js'></script>

    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="/" style="text-decoration: none;">
                    <div class="logo">
                        
                            ⭐Widowmake⭐
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://widowmaker2025.github.io">Blog</a></li>
            
                <li><a href="https://widowmaker2025.github.io/tags">Tags </a></li>
            
                <li><a href="https://widowmaker2025.github.io/archive">Archive</a></li>
            
                <li><a href="https://widowmaker2025.github.io/about">about me |关于我</a></li>
            
                <li><a href="https://github.com/Widowmaker2025" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="toc-container"><div class="toc"></div></div>
    
    <div class="content">
        
    <div class="post">
        
    <h1 data-pagefind-meta="title" class="post-title">
            <b><a href="https://widowmaker2025.github.io/gitban-ben-guan-li-zhuan-zai/">Git版本管理</a></b>
        </h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2025-05-02
        </span>

    </div>

    
        <span class="post-tags-inline">
            ::
                <a data-pagefind-filter="Tags" class="post-tag" href="https://widowmaker2025.github.io/tags/git/">#git</a>&nbsp;
                <a data-pagefind-filter="Tags" class="post-tag" href="https://widowmaker2025.github.io/tags/ji-chu-ji-neng/">#基础技能</a>&nbsp;
                <a data-pagefind-filter="Tags" class="post-tag" href="https://widowmaker2025.github.io/tags/zhuan-zai/">#转载</a></span>
    

        
        <div class="post-content" id="uniq-post-content" data-pagefind-body>
            <blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.hanqunfeng.com/2021/10/29/git-command/?highlight=git">blog.hanqunfeng.com</a></p>
</blockquote>
<blockquote>
<p>摘要 一起来了解一些 git 常用命令吧 推荐一个学习 git 命令的网站：https://learngitbranching.js.org/?locale=zh_CN</p>
</blockquote>
<h2 id="zhai-yao">摘要</h2>
<ul>
<li>一起来了解一些 git 常用命令吧</li>
<li>推荐一个学习 git 命令的网站：<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a><br />
[<img src="data:application/xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEVycm9yPgogIDxDb2RlPk5vU3VjaEtleTwvQ29kZT4KICA8TWVzc2FnZT5UaGUgc3BlY2lmaWVkIGtleSBkb2VzIG5vdCBleGlzdC48L01lc3NhZ2U+CiAgPFJlcXVlc3RJZD42ODE0MjI2MTQ3OEFCMzM0MzRFQTc4NEU8L1JlcXVlc3RJZD4KICA8SG9zdElkPnVwaWMtb3NzLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbTwvSG9zdElkPgogIDxLZXk+YmxvZy9naXQucG5naHR0cHM6Ly91cGljLW9zcy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vYmxvZy9naXQucG5nPC9LZXk+CiAgPEVDPjAwMjYtMDAwMDAwMDE8L0VDPgogIDxSZWNvbW1lbmREb2M+aHR0cHM6Ly9hcGkuYWxpeXVuLmNvbS90cm91Ymxlc2hvb3Q/cT0wMDI2LTAwMDAwMDAxPC9SZWNvbW1lbmREb2M+CjwvRXJyb3I+Cg==" alt="" /></li>
</ul>
<h2 id="ji-ben-gai-nian">基本概念</h2>
<h3 id="git-de-5-chong-gong-zuo-qu-yu">Git 的 5 种工作区域</h3>
<ul>
<li>
<p>工作目录：用于新增、修改、删除文件，实际我们用于编写代码的目录</p>
</li>
<li>
<p>暂存区：执行<code>add</code>命令可以将工作目录对应的文件提交到暂存区，只有加入到暂存区的文件才会参与版本控制，其实际为一堆索引文件，保存在<code>.git/objects</code>目录下，记录每个文件的快照（hash）</p>
</li>
<li>
<p>本地版本库：执行<code>commit</code>命令可以将暂存区的文件提交到本地版本库，每一次提交都会记录版本日志，其实际保存位置也是<code>.git/objects</code>目录下的快照文件，每一次<code>commit</code>如果文件发生变化都会生成新的快照，<code>.git/refs/heads/</code>下记录每个分支的最新一次 commit 的版本号</p>
</li>
<li>
<p>远程跟踪区：<code>.git/refs/remotes/origin/</code>下记录每个分支的最新一次更新后的远程版本号，执行<code>fetch\pull\push</code>时都会更新为最新的远程版本号。如果只执行<code>fetch</code>仅仅会更新远程跟踪区，并不会更新本地目录，执行<code>pull</code>命令会同时更新远程跟踪区和本地目录</p>
</li>
<li>
<p>远程版本库：例如 github</p>
</li>
</ul>
<h3 id="wen-jian-de-zhuang-tai">文件的状态</h3>
<ul>
<li>Untracked: 未跟踪的文件，尚未加入过暂存区的文件</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>➜  git:(release) touch a.txt
</span><span>➜  git:(release) ✗ git status
</span><span>位于分支 release
</span><span>您的分支与上游分支 &#39;origin/release&#39; 一致。
</span><span>
</span><span>未跟踪的文件:
</span><span>  （使用 &quot;git add &lt;文件&gt;...&quot; 以包含要提交的内容）
</span><span>	a.txt
</span><span>
</span><span>提交为空，但是存在尚未跟踪的文件（使用 &quot;git add&quot; 建立跟踪）
</span></code></pre>
<ul>
<li>要提交的变更 [新增]，加入暂存区</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>➜  git:(release) ✗ git add .
</span><span>➜  git:(release) ✗ git status
</span><span>位于分支 release
</span><span>您的分支与上游分支 &#39;origin/release&#39; 一致。
</span><span>
</span><span>要提交的变更：
</span><span>  （使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存）
</span><span>	新文件：   a.txt
</span></code></pre>
<ul>
<li>已提交版本库待发布到远端，将暂存区的文件加入本地版本库</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>➜  git:(release) ✗ git commit -m &#39;add a.txt&#39;
</span><span>[release 9292bb2] add a.txt
</span><span> 1 file changed, 0 insertions(+), 0 deletions(-)
</span><span> create mode 100644 a.txt
</span><span>➜  git:(release) git status
</span><span>位于分支 release
</span><span>您的分支领先 &#39;origin/release&#39; 共 1 个提交。
</span><span>  （使用 &quot;git push&quot; 来发布您的本地提交）
</span><span>
</span><span>无文件要提交，干净的工作区
</span></code></pre>
<ul>
<li>尚未暂存以备提交的变更，加入过暂存区的文件发生修改</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>➜  git:(release) echo &quot;hello&quot; &gt;&gt; a.txt
</span><span>➜  git:(release) ✗ git status
</span><span>位于分支 release
</span><span>您的分支领先 &#39;origin/release&#39; 共 1 个提交。
</span><span>  （使用 &quot;git push&quot; 来发布您的本地提交）
</span><span>
</span><span>尚未暂存以备提交的变更：
</span><span>  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）
</span><span>  （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动）
</span><span>	修改：     a.txt
</span><span>
</span><span>修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）
</span></code></pre>
<ul>
<li>要提交的变更 [修改]，加入过暂存区的文件重新加入暂存区</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>➜  git:(release) ✗ git add .
</span><span>➜  git:(release) ✗ git status
</span><span>位于分支 release
</span><span>您的分支领先 &#39;origin/release&#39; 共 1 个提交。
</span><span>  （使用 &quot;git push&quot; 来发布您的本地提交）
</span><span>
</span><span>要提交的变更：
</span><span>  （使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存）
</span><span>	修改：     a.txt
</span></code></pre>
<h3 id="qie-huan-fen-zhi-shi-zhi-de-zhu-yi-de-di-fang">切换分支时值得注意的地方</h3>
<ul>
<li>
<p>只要文件没有被 commit，无论是新增还是修改，切换分支时，文件的状态都会被带到切换后的分支</p>
</li>
<li>
<p>所以切换分支前，一定要执行 commit</p>
</li>
</ul>
<h3 id="head-zhi-zhen-he-fen-zhi-zhi-zhen">HEAD 指针和分支指针</h3>
<ul>
<li>
<p>我们在查看 git 的 log 时会看到类似于<code>* 6d93a15 (HEAD -&gt; master) message</code>这样的信息，6d93a15 就是 commit 时的版本号，master 是分支名称，HEAD 就是<code>HEAD指针</code>，实际上这里的 master 也是一个指针，他就是<code>分支指针</code></p>
</li>
<li>
<p><code>分支指针</code>永远指向当前分支最新的一次提交版本，分支指针对应版本号保存在<code>.git/refs/heads/</code>目录下对应的分支文件中</p>
</li>
<li>
<p><code>HEAD指针</code>表示我们当前的工作目录是基于哪个版本 checkout 出来的，通常情况下<code>HEAD指针</code>指向<code>分支指针</code>，但当我们通过命令<code>git checkout &lt;commit号&gt;</code>切换到某个版本时，<code>HEAD指针</code>就不再指向<code>分支指针</code>，这个情况有个名字叫作<code>detached HEAD(头分离)</code>，<code>HEAD指针</code>对应的版本号保存在<code>.git/HEAD</code>文件中，这也是为什么我们每次进入项目，git 都知道我们当前所在分支或版本号是什么。</p>
</li>
<li>
<p>参考资料：<a href="https://www.zsythink.net/archives/3412/">https://www.zsythink.net/archives/3412/</a></p>
</li>
</ul>
<h2 id="wen-ti-yu-fang-fa">问题与方法</h2>
<h3 id="1-bie-ren-zai-yuan-cheng-cang-ku-zhong-chuang-jian-liao-xin-de-branch-wo-ben-di-zhi-xing-git-branch-aque-kan-bu-dao-ru-he-cai-neng-kan-dao-bing-checkout-ni">1. 别人在远程仓库中创建了新的 branch，我本地执行<code>git branch -a</code>却看不到，如何才能看到并 checkout 呢？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git fetch origin
</span><span>
</span><span>git fetch 
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>git branch -a
</span><span>
</span><span>
</span><span>git checkout -b release（本地分支名） origin/release（远程分支名）
</span><span>控制台输出：
</span><span>分支 &#39;release&#39; 设置为跟踪来自 &#39;origin&#39; 的远程分支 &#39;release&#39;。
</span><span>切换到一个新分支 &#39;release&#39;
</span><span>
</span><span>
</span><span>git rev-parse --abbrev-ref --symbolic-full-name @{u}  
</span><span>控制台输出：
</span><span>origin/release
</span></code></pre>
<h3 id="2-ru-he-cha-kan-ben-di-fen-zhi-yu-yuan-cheng-fen-zhi-de-qu-bie">2. 如何查看本地分支与远程分支的区别？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git fetch origin
</span><span>
</span><span>git fetch
</span><span>
</span><span>
</span><span>git checkout master
</span><span>
</span><span>
</span><span>git diff origin/master --stat
</span><span>
</span><span>
</span><span>git diff origin/master..master --stat
</span></code></pre>
<h3 id="3-ru-he-cha-kan-ben-di-liang-ge-fen-zhi-zhi-jian-de-qu-bie">3. 如何查看本地两个分支之间的区别？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git diff master..dev --stat
</span><span>
</span><span>
</span><span>git diff master --stat
</span></code></pre>
<h3 id="4-ru-he-cha-kan-ben-di-de-fa-sheng-liao-na-xie-geng-gai">4. 如何查看本地的发生了哪些更改？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git diff --stat
</span><span>
</span><span>
</span><span>git status
</span><span>
</span><span>
</span><span>git diff --cached --stat
</span><span>
</span><span>
</span><span>git diff HEAD --stat
</span></code></pre>
<h3 id="5-ru-he-ti-jiao-ben-di-cang-ku">5. 如何提交本地仓库？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git add .
</span><span>git commit -m &#39;message&#39;
</span><span>
</span><span>
</span><span> git commit -a -m &#39;message&#39;
</span></code></pre>
<h3 id="6-git-reset-ru-he-hui-gun-dao-zhi-ding-ban-ben-huo-fen-zhi">6.<code>git reset</code>: 如何回滚到指定版本或分支?</h3>
<ul>
<li>
<p>git reset 的作用是修改 HEAD 的位置，即将 HEAD 指向的位置改变为之前存在的某个版本，如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法。</p>
</li>
<li>
<p>注意，如果 reset 包含了已经发布（<code>git push</code>）的的版本，此时如果用<code>git push</code>会报错，因为我们本地库 HEAD 指向的版本比远程库的要旧，需要执行命令<code>git push -f</code>强制更新远程</p>
</li>
<li>
<p>注意参数<code>--hard</code>有和没有的区别，有–hard，则完全回退到上一版本，丢弃所有其它修改，清空暂存区，同步工作目录到指定版本。没有–hard，则该版本之后的变化会变为 Modified 状态保留在工作目录，只清空暂存区。</p>
</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git reset --hard HEAD^ 
</span><span>git reset HEAD~1 
</span><span>
</span><span>
</span><span>git reset --hard HEAD^^
</span><span>git reset HEAD~2
</span><span>
</span><span>
</span><span>git reset --hard 版本号
</span><span>
</span><span>
</span><span>git log --oneline
</span><span>
</span><span>
</span><span>git reset --hard 分支名称
</span><span>
</span><span>
</span><span>git reset --hard origin/master
</span><span>
</span><span>
</span><span>git reflog
</span></code></pre>
<h3 id="7-gitignore-zai-git-zhong-ru-guo-xiang-hu-lue-diao-mou-ge-wen-jian-bu-rang-zhe-ge-wen-jian-ti-jiao-dao-ban-ben-ku-zhong-yao-zen-me-zuo-ni">7.<code>.gitignore</code>: 在 git 中如果想忽略掉某个文件，不让这个文件提交到版本库中，要怎么做呢？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>*.a       
</span><span>!lib.a    
</span><span>/TODO     
</span><span>build/    
</span><span>doc/*.txt 
</span><span>
</span><span>
</span><span>git config core.excludesfile .gitignore_dev
</span><span>
</span><span>
</span><span>git config --global core.excludesfile ~/.gitignore_global
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>git rm --cached 文件名   
</span><span>git rm -r --cached 文件夹   
</span><span>git rm -r --cached .  
</span><span>
</span><span>git rm -r 文件夹/文件名  
</span><span>
</span><span>
</span><span>git add . 
</span><span>git add file/dir 
</span><span>
</span><span>
</span><span>git diff --cached
</span><span>
</span><span>
</span><span>git commit -m &quot;message&quot; 
</span><span>git commit -am &quot;message&quot;
</span></code></pre>
<h3 id="8-git-commit-amend-commit-hou-fa-xian-you-nei-rong-yao-xiu-gai-huo-zhe-zhu-shi-xie-cuo-liao-dan-shi-bu-xiang-chuang-jian-xin-de-yi-ci-commit-yao-zen-me-ban-ni">8.<code>git commit --amend</code>: commit 后发现有内容要修改或者注释写错了，但是不想创建新的一次 commit，要怎么办呢？</h3>
<ul>
<li>以下命令如果直接合并到已经 push 过的版本，再次 git push 时会提示 "更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支"，此时可以执行<code>git push -f</code>强行发布即可。</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git commit --amend  -am &quot;注释&quot;
</span><span>
</span><span>
</span><span>git commit -a --amend --no-edit
</span></code></pre>
<h3 id="9-git-log-ru-he-cha-kan-ti-jiao-ri-zhi">9.<code>git log</code>–如何查看提交日志?</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git log  
</span><span>git log  --all 
</span><span>git log --oneline 
</span><span>
</span><span>git log --oneline --all --graph 
</span><span>
</span><span>
</span><span>git log --all --grep=&#39;homepage&#39; 
</span><span>
</span><span>
</span><span>git log --author=&quot;hanqf&quot;  
</span><span>
</span><span>
</span><span>git reflog
</span></code></pre>
<h3 id="10-ru-he-chuang-jian-ben-di-cang-ku-bing-bang-ding-dao-yuan-cheng-cang-ku">10. 如何创建本地仓库并绑定到远程仓库?</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git init 
</span><span>git init dir 
</span><span>
</span><span>git branch -m &lt;name&gt;
</span><span>
</span><span>git config --global init.defaultBranch &lt;名称&gt;
</span><span>
</span><span>
</span><span>git add . &amp;&amp; git commit -m &#39;message&#39;
</span><span>git commit -am &quot;备注&quot;
</span><span>
</span><span>
</span><span>git remote add origin https://xxxxx (远程仓库地址)
</span><span>
</span><span>
</span><span>git pull --rebase origin master 
</span><span>git push -u origin master 
</span><span>git push origin master
</span><span>
</span><span>git push
</span></code></pre>
<h3 id="11-yuan-cheng-cang-ku-di-zhi-bian-geng-hou-ru-he-geng-xin">11. 远程仓库地址变更后如何更新？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git remote set-url origin [NEW_URL]
</span><span>
</span><span>
</span><span>[remote &quot;origin&quot;]
</span><span>    url = https://xxxxxx (修改为新的地址)
</span><span>    fetch = +refs/heads/*:refs/remotes/origin/*
</span><span>
</span><span>
</span><span>git remote get-url origin   
</span><span>
</span><span>
</span><span>git remote -v
</span></code></pre>
<h3 id="12-ru-he-jiang-ben-di-cang-ku-tong-shi-bang-ding-dao-duo-ge-yuan-cheng-cang-ku">12. 如何将本地仓库同时绑定到多个远程仓库？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>[remote &quot;origin&quot;]
</span><span>    url = https://xxxxxxxx1  
</span><span>    url = https://xxxxxxxx2  
</span><span>    fetch = +refs/heads/*:refs/remotes/origin/*
</span><span>
</span><span>
</span><span>git push -u origin master  
</span><span>
</span><span>git push 
</span><span>
</span><span>
</span><span>git remote -v
</span></code></pre>
<h3 id="13-ru-he-zai-git-pullshi-bu-yong-mei-ci-du-shu-ru-mi-ma">13. 如何在<code>git pull</code>时不用每次都输入密码？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git config --global credential.helper store
</span><span>
</span><span>
</span><span>git pull
</span></code></pre>
<h3 id="14-ru-guo-wen-jian-yi-jing-git-adddao-zan-cun-qu-dan-shi-shang-wei-commit-ci-shi-ru-he-jiang-wen-jian-cong-zan-cun-qu-zhong-yi-chu">14. 如果文件已经<code>git add</code>到暂存区，但是尚未 commit，此时如何将文件从暂存区中移除？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git checkout -- &lt;文件名&gt; 
</span><span>
</span><span>
</span><span>
</span><span>git restore --staged &lt;文件路径&gt;
</span><span>
</span><span>
</span><span>git reset .  
</span><span>
</span><span>
</span><span>git status
</span><span>
</span><span>
</span><span>
</span><span>git rm --cached &lt;文件名&gt;   
</span><span>git rm -r --cached &lt;文件夹&gt;   
</span><span>git rm -r --cached .
</span></code></pre>
<h3 id="15-git-config-ru-he-she-zhi-he-cha-kan-git-pei-zhi-xin-xi">15.<code>git config</code>: 如何设置和查看 git 配置信息？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git config --global user.name &quot;你的用户名&quot;
</span><span>git config --global user.email &quot;你的邮箱&quot;
</span><span>
</span><span>
</span><span>git config user.name &quot;你的用户名&quot;
</span><span>git config user.email &quot;你的邮箱&quot;
</span><span>
</span><span>
</span><span>git config --global --replace-all user.name &quot;你的用户名&quot;
</span><span>git config --global --replace-all user.email &quot;你的邮箱&quot;
</span><span>
</span><span>
</span><span>git config --list  
</span><span>
</span><span>git config --global --list 
</span><span>
</span><span>git config user.name 
</span><span>
</span><span>
</span><span>git config --global --replace-all user.name &quot;你的用户名&quot;
</span><span>git config --global --replace-all user.email &quot;你的邮箱&quot;
</span><span>
</span><span>
</span><span>git config --replace-all user.name &quot;你的用户名&quot;
</span><span>git config --replace-all user.email &quot;你的邮箱&quot;
</span></code></pre>
<h3 id="16-ti-jiao-de-wen-jian-tai-da-mo-ren-shi-1m-dao-zhi-push-shi-bai-zen-me-ban">16. 提交的文件太大 (默认是 1M)，导致 push 失败怎么办？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git config http.postBuffer 524288000
</span><span>
</span><span>git config --global http.postBuffer 524288000
</span></code></pre>
<h3 id="17-clone-dai-ma-zui-jian-dan-de-fang-shi-shi-tong-guo-https-de-xing-shi-bu-guo-yi-ban-zhe-yang-zuo-xu-yao-shu-ru-yong-hu-ming-he-mi-ma-ru-guo-bu-xiang-shu-ru-yong-hu-ming-he-mi-ma-ke-yi-shi-yong-git-xxxxde-xing-shi-ru-he-shi-xian-ni">17.clone 代码最简单的方式是通过 https 的形式，不过一般这样做需要输入用户名和密码，如果不想输入用户名和密码可以使用<code>git@xxxx</code>的形式，如何实现呢？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>ssh-keygen -b 4096 -t rsa 
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>ssh-keygen -b 4096 -t rsa -C &quot;xxxxxxx&quot;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>ssh -T git@github.com
</span><span>
</span><span>
</span><span>ssh -T git@e.coding.net
</span><span>
</span><span>
</span><span>
</span><span>ssh -T git@gitee.com
</span><span>
</span><span>
</span><span>git clone git@github.com:hanqunfeng/reactive-redis-cache-annotation-spring-boot-starter.git
</span></code></pre>
<h3 id="18-git-branch-ru-he-chuang-jian-fen-zhi-qie-huan-fen-zhi-cha-kan-fen-zhi-shan-chu-fen-zhi-fa-bu-fen-zhi">18.<code>git branch</code>: 如何创建分支 \ 切换分支 \ 查看分支 \ 删除分支 \ 发布分支？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git branch release
</span><span>
</span><span>git checkout release 
</span><span>git checkout &lt;commit号&gt; 
</span><span>
</span><span>
</span><span>
</span><span>git checkout -b release
</span><span>
</span><span>
</span><span>git branch release dev
</span><span>
</span><span>git checkout -b release dev
</span><span>
</span><span>
</span><span>git branch release 799fb04
</span><span>git checkout -b release 799fb04
</span><span>
</span><span>
</span><span>
</span><span>git checkout -b release origin/release
</span><span>
</span><span>
</span><span>git checkout -
</span><span>
</span><span>
</span><span>git branch  
</span><span>git branch --remote   
</span><span>git branch -a  
</span><span>
</span><span>cat .git/HEAD  
</span><span>git symbolic-ref HEAD 
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>git branch -d release
</span><span>
</span><span>
</span><span>git branch -D release  
</span><span>
</span><span>
</span><span>git push --set-upstream origin &lt;new branch name&gt; 
</span><span>
</span><span>git push origin &lt;new branch name&gt; 
</span><span>git branch --set-upstream-to=origin/&lt;new branch name&gt; &lt;new branch name&gt; 
</span><span>
</span><span>
</span><span>git rev-parse --abbrev-ref --symbolic-full-name @{u}
</span></code></pre>
<h3 id="19-merge-huan-shi-rebase-ru-he-he-bing-fen-zhi">19.merge 还是 rebase? 如何合并分支?</h3>
<p>一般开发流程：</p>
<ol>
<li>
<p>更新主分支 git pull</p>
</li>
<li>
<p>从主分支创建一个开发分支 git checkout -b dev，每个开发人员都会创建一个自己的开发分支</p>
</li>
<li>
<p>开发分支完成测试后合并回主分支，这里推荐使用 git rebase，开发分支的 log 会被移动到主分支的顶端，这样主分支始终是一条线</p>
</li>
<li>
<p>这样主分支在保持干净的同时还保留了每一次 commit 的 log，便于开发人员追溯历史</p>
</li>
<li>
<p>也可以使用<code>git merge --no-ff</code>，其也会保留每次的 log 到主分支上</p>
</li>
</ol>
<p>一般发布流程：</p>
<ol>
<li>
<p>将主分支测试完成后合并到发布分支，一般都是由一个专门的人员进行合并，此时推荐使用 git merge，这样每次一发布的版本都会产生一个新的节点，而主分支上的多次 commit 的 log 不会被记录到发布分支上</p>
</li>
<li>
<p>这样发布分支看起来就是每一次大的发布才会合并一次并记录 log，log 中可以编辑本次发布的内容。</p>
</li>
</ol>
<h4 id="shi-li-zhun-bei-chu-shi-hua-yi-ge-dai-he-bing-de-mu-lu">示例准备，初始化一个待合并的目录</h4>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>➜ mkdir git_test
</span><span>➜ cd git_test
</span><span>➜ touch 1.txt
</span><span>➜ git init
</span><span>[master（根提交） 5b91fc1] init...
</span><span> 1 files changed, 0 insertions(+), 0 deletions(-)
</span><span> create mode 100644 1.txt
</span><span>➜ git:(master) git add . &amp;&amp; git commit -m &#39;init...&#39;
</span><span>➜ git:(master) git checkout -b dev
</span><span>➜ git:(dev) echo &quot;dev1&quot; &gt;&gt; a.txt
</span><span>➜ git:(dev) ✗ git add . &amp;&amp; git commit -m &#39;dev1&#39;
</span><span>[dev 8d57739] dev1
</span><span> 1 file changed, 1 insertion(+)
</span><span> create mode 100644 a.txt
</span><span>➜ git:(dev) ✗ git checkout master
</span><span>切换到分支 &#39;master&#39;
</span><span>➜ git:(master) ✗ echo &quot;master1&quot; &gt;&gt; a.txt
</span><span>➜ git:(master) ✗ git add . &amp;&amp; git commit -m &#39;master1&#39;
</span><span>[master fa2400a] master1
</span><span> 1 file changed, 1 insertion(+)
</span><span> create mode 100644 a.txt
</span><span>➜ git:(master) ✗ git checkout dev
</span><span>切换到分支 &#39;dev&#39;
</span><span>➜ git:(dev) ✗ echo &quot;dev2&quot; &gt;&gt; a.txt
</span><span>➜ git:(dev) ✗ git add . &amp;&amp; git commit -m &#39;dev2&#39;
</span><span>[dev 0006560] dev2
</span><span> 1 file changed, 1 insertion(+)
</span><span>➜ git:(dev) ✗ git checkout master
</span><span>切换到分支 &#39;master&#39;
</span></code></pre>
<h4 id="merge">merge</h4>
<p>将 dev 分支 merge 到当前分支</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git merge dev
</span></code></pre>
<ul>
<li>merge 会将 dev 分支和当前分支合并后创建一个新的节点放到当前分支最顶端，所以解决完冲突，需要执行如下命令创建一个新的 commit</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git add . &amp;&amp; git commit -m &#39;merge dev&#39;
</span></code></pre>
<ul>
<li>
<p>merge 的 log 会按照时间顺序显示</p>
</li>
<li>
<p>merge 后如果删除了 dev 分支，则在 log 中就看不到这个分支信息了，但是日志内容还在</p>
</li>
</ul>
<h5 id="merge-shi-li">merge 示例</h5>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>➜ git:(master) ✗ git merge dev
</span><span>冲突（add/add）：合并冲突于 a.txt
</span><span>自动合并 a.txt
</span><span>自动合并失败，修正冲突然后提交修正的结果。
</span><span>➜ git:(master) ✗ vim a.txt
</span><span>➜ git:(master) ✗ git add . &amp;&amp; git commit -m &#39;master merge release&#39;
</span><span>➜ git:(master) git log --oneline   
</span><span>➜ git:(master) git branch -D dev
</span><span>已删除分支 dev（曾为 0006560）。
</span></code></pre>
<p>[<img src="data:application/xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEVycm9yPgogIDxDb2RlPk5vU3VjaEtleTwvQ29kZT4KICA8TWVzc2FnZT5UaGUgc3BlY2lmaWVkIGtleSBkb2VzIG5vdCBleGlzdC48L01lc3NhZ2U+CiAgPFJlcXVlc3RJZD42ODE0MjI2MTQ3OEFCMzM0MzQyRDc5NEU8L1JlcXVlc3RJZD4KICA8SG9zdElkPnVwaWMtb3NzLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbTwvSG9zdElkPgogIDxLZXk+YmxvZy9tZXJnZTEucG5naHR0cHM6Ly91cGljLW9zcy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vYmxvZy9tZXJnZTEucG5nPC9LZXk+CiAgPEVDPjAwMjYtMDAwMDAwMDE8L0VDPgogIDxSZWNvbW1lbmREb2M+aHR0cHM6Ly9hcGkuYWxpeXVuLmNvbS90cm91Ymxlc2hvb3Q/cT0wMDI2LTAwMDAwMDAxPC9SZWNvbW1lbmREb2M+CjwvRXJyb3I+Cg==" alt="" /><br />
删除 dev 分支后<br />
[<img src="data:application/xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEVycm9yPgogIDxDb2RlPk5vU3VjaEtleTwvQ29kZT4KICA8TWVzc2FnZT5UaGUgc3BlY2lmaWVkIGtleSBkb2VzIG5vdCBleGlzdC48L01lc3NhZ2U+CiAgPFJlcXVlc3RJZD42ODE0MjI2MjQ3OEFCMzM0MzQ1QTc5NEU8L1JlcXVlc3RJZD4KICA8SG9zdElkPnVwaWMtb3NzLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbTwvSG9zdElkPgogIDxLZXk+YmxvZy9tZXJnZTIucG5naHR0cHM6Ly91cGljLW9zcy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vYmxvZy9tZXJnZTIucG5nPC9LZXk+CiAgPEVDPjAwMjYtMDAwMDAwMDE8L0VDPgogIDxSZWNvbW1lbmREb2M+aHR0cHM6Ly9hcGkuYWxpeXVuLmNvbS90cm91Ymxlc2hvb3Q/cT0wMDI2LTAwMDAwMDAxPC9SZWNvbW1lbmREb2M+CjwvRXJyb3I+Cg==" alt="" /></p>
<h4 id="rebase">rebase</h4>
<p>将 dev 分支 rebase 到当前分支</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git rebase dev
</span></code></pre>
<ul>
<li>
<p>rebase 会将 dev 分支的每一个节点转移到当前分支最顶端，而不会产生一个新的节点，这样 rebase 后的分支节点看起来就是一条线</p>
</li>
<li>
<p>解决完冲突，执行<code>git add .</code>和<code>git rebase --continue</code>，不会产生额外的 commit</p>
</li>
<li>
<p>rebase 后如果删除了 dev 分支，则在 log 中就看不到这个分支信息了，但是日志内容还在，这样看起来就是主分支自己的节点，没有产生过新的分支</p>
</li>
<li>
<p>如果要放弃本次合并，可以运行<code>git rebase --abort</code></p>
</li>
</ul>
<h5 id="rebase-shi-li">rebase 示例</h5>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>➜  git:(master) git rebase dev
</span><span>冲突（add/add）：合并冲突于 a.txt
</span><span>自动合并 a.txt
</span><span>error: 不能应用 0657382... master1
</span><span>Resolve all conflicts manually, mark them as resolved with
</span><span>&quot;git add/rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.
</span><span>You can instead skip this commit: run &quot;git rebase --skip&quot;.
</span><span>To abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;.
</span><span>不能应用 0657382... master1
</span><span>➜  git:(e4410b4) ✗ vim a.txt
</span><span>➜  git:(e4410b4) ✗ git add .
</span><span>➜  git:(e4410b4) ✗ git rebase --continue
</span><span>[分离头指针 bd01ea0] master1
</span><span> 1 file changed, 1 insertion(+)
</span><span>成功变基并更新 refs/heads/master。
</span><span>➜  git:(master) git log --oneline
</span><span>➜  git:(master) git branch -D dev
</span><span>已删除分支 dev（曾为 e4410b4）。
</span></code></pre>
<p>[<img src="data:application/xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEVycm9yPgogIDxDb2RlPk5vU3VjaEtleTwvQ29kZT4KICA8TWVzc2FnZT5UaGUgc3BlY2lmaWVkIGtleSBkb2VzIG5vdCBleGlzdC48L01lc3NhZ2U+CiAgPFJlcXVlc3RJZD42ODE0MjI2MjQ3OEFCMzM0MzQ5Mjc5NEU8L1JlcXVlc3RJZD4KICA8SG9zdElkPnVwaWMtb3NzLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbTwvSG9zdElkPgogIDxLZXk+YmxvZy9yZWJhc2UxLnBuZ2h0dHBzOi8vdXBpYy1vc3Mub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Jsb2cvcmViYXNlMS5wbmc8L0tleT4KICA8RUM+MDAyNi0wMDAwMDAwMTwvRUM+CiAgPFJlY29tbWVuZERvYz5odHRwczovL2FwaS5hbGl5dW4uY29tL3Ryb3VibGVzaG9vdD9xPTAwMjYtMDAwMDAwMDE8L1JlY29tbWVuZERvYz4KPC9FcnJvcj4K" alt="" /><br />
删除 dev 分支后<br />
[<img src="data:application/xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEVycm9yPgogIDxDb2RlPk5vU3VjaEtleTwvQ29kZT4KICA8TWVzc2FnZT5UaGUgc3BlY2lmaWVkIGtleSBkb2VzIG5vdCBleGlzdC48L01lc3NhZ2U+CiAgPFJlcXVlc3RJZD42ODE0MjI2MjQ3OEFCMzM0MzRDMDc5NEU8L1JlcXVlc3RJZD4KICA8SG9zdElkPnVwaWMtb3NzLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbTwvSG9zdElkPgogIDxLZXk+YmxvZy9yZWJhc2UyLnBuZ2h0dHBzOi8vdXBpYy1vc3Mub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Jsb2cvcmViYXNlMi5wbmc8L0tleT4KICA8RUM+MDAyNi0wMDAwMDAwMTwvRUM+CiAgPFJlY29tbWVuZERvYz5odHRwczovL2FwaS5hbGl5dW4uY29tL3Ryb3VibGVzaG9vdD9xPTAwMjYtMDAwMDAwMDE8L1JlY29tbWVuZERvYz4KPC9FcnJvcj4K" alt="" /></p>
<h3 id="20-git-rebase-i-wo-commit-liao-hen-duo-ci-fa-xian-du-shi-gan-de-yi-jian-shi-ci-shi-ru-guo-zhi-jie-rebase-dao-zhu-fen-zhi-hui-you-hen-duo-mei-bi-yao-de-log-shi-fou-ke-yi-he-bing-zhe-xie-commit-wei-yi-ge-ni">20.<code>git rebase -i</code>: 我 commit 了很多次，发现都是干的一件事，此时如果直接 rebase 到主分支会有很多没必要的 log，是否可以合并这些 commit 为一个呢？</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git rebase -i  commit号 
</span><span>git rebase -i  start_commit号 end_commit号  
</span><span>git rebase -i HEAD~3   
</span><span>
</span><span>
</span><span>git rebase -i  分支名称
</span></code></pre>
<ul>
<li>
<p>如果修改的提交节点距离结束的提交节点中间有多个节点，而上一次和下一次都需要合并文件，这个过程就要进行多次。个人感觉这个过程虽然可以重新整理提交节点，使节点更准确清晰，但是如果修改的点比较远，文件内容变化复杂，这个多次合并的过程还是比较痛苦的，不推荐在这种情况下使用。</p>
</li>
<li>
<p>推荐的使用场景为，针对同一个功能进行修改，在 commit 后尚未进行 pushsa 时发现有些内容需要变化，如果此时没有进行 commit，可以执行<code>git commit --amend -am "注释"</code>, 如果已经执行了 commit，则可以执行<code>git rebase -i HEAD~2</code>。</p>
</li>
</ul>
<h4 id="shi-li">示例</h4>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git rebase -i HEAD~3
</span></code></pre>
<ul>
<li>
<p>注意这里会进入两次编辑页面，一次是多个提交的处理方式，按提示进行修改即可，一般保留第一行的命令 pick，后面的行命令修改为 s，然后 wq 保存。</p>
</li>
<li>
<p>注意合并多个分支时如果包含已经发布过的分支，就要调整顺序，将已经发布的最后一个分支放到第一行，否则再次发布时会提示需要先执行<code>git pull</code>，这是因为按照上面的逻辑只有第一行的是提交操作，后面的不会产生新的提交，所以版本号就会落后于远端分支，但是即便调整顺序，也会提示版本偏离，还是要先执行<code>git pull</code>，待手工合并冲突后再次提交一个新的 commit，所以，最好的方法就是不要包含已经发布过的分支，只针对未发布的分支进行合并。<br />
编辑后的：<br />
[<img src="data:application/xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEVycm9yPgogIDxDb2RlPk5vU3VjaEtleTwvQ29kZT4KICA8TWVzc2FnZT5UaGUgc3BlY2lmaWVkIGtleSBkb2VzIG5vdCBleGlzdC48L01lc3NhZ2U+CiAgPFJlcXVlc3RJZD42ODE0MjI2MjQ3OEFCMzM0MzRGMDc5NEU8L1JlcXVlc3RJZD4KICA8SG9zdElkPnVwaWMtb3NzLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbTwvSG9zdElkPgogIDxLZXk+YmxvZy9yZWJhc2UzLnBuZ2h0dHBzOi8vdXBpYy1vc3Mub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Jsb2cvcmViYXNlMy5wbmc8L0tleT4KICA8RUM+MDAyNi0wMDAwMDAwMTwvRUM+CiAgPFJlY29tbWVuZERvYz5odHRwczovL2FwaS5hbGl5dW4uY29tL3Ryb3VibGVzaG9vdD9xPTAwMjYtMDAwMDAwMDE8L1JlY29tbWVuZERvYz4KPC9FcnJvcj4K" alt="" /></p>
</li>
<li>
<p>第二个页面是要求你编辑本次合并的 log 说明，此时每次的 log 都会显示在这个页面，去掉不需要的，重新编辑一下保存即可。<br />
[<img src="data:application/xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEVycm9yPgogIDxDb2RlPk5vU3VjaEtleTwvQ29kZT4KICA8TWVzc2FnZT5UaGUgc3BlY2lmaWVkIGtleSBkb2VzIG5vdCBleGlzdC48L01lc3NhZ2U+CiAgPFJlcXVlc3RJZD42ODE0MjI2MjQ3OEFCMzM0MzQyRDdBNEU8L1JlcXVlc3RJZD4KICA8SG9zdElkPnVwaWMtb3NzLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbTwvSG9zdElkPgogIDxLZXk+YmxvZy9yZWJhc2U0LnBuZ2h0dHBzOi8vdXBpYy1vc3Mub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Jsb2cvcmViYXNlNC5wbmc8L0tleT4KICA8RUM+MDAyNi0wMDAwMDAwMTwvRUM+CiAgPFJlY29tbWVuZERvYz5odHRwczovL2FwaS5hbGl5dW4uY29tL3Ryb3VibGVzaG9vdD9xPTAwMjYtMDAwMDAwMDE8L1JlY29tbWVuZERvYz4KPC9FcnJvcj4K" alt="" /><br />
编辑后的：<br />
[<img src="data:application/xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEVycm9yPgogIDxDb2RlPk5vU3VjaEtleTwvQ29kZT4KICA8TWVzc2FnZT5UaGUgc3BlY2lmaWVkIGtleSBkb2VzIG5vdCBleGlzdC48L01lc3NhZ2U+CiAgPFJlcXVlc3RJZD42ODE0MjI2MjQ3OEFCMzM0MzQ2RDdBNEU8L1JlcXVlc3RJZD4KICA8SG9zdElkPnVwaWMtb3NzLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbTwvSG9zdElkPgogIDxLZXk+YmxvZy9yZWJhc2U1LnBuZ2h0dHBzOi8vdXBpYy1vc3Mub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Jsb2cvcmViYXNlNS5wbmc8L0tleT4KICA8RUM+MDAyNi0wMDAwMDAwMTwvRUM+CiAgPFJlY29tbWVuZERvYz5odHRwczovL2FwaS5hbGl5dW4uY29tL3Ryb3VibGVzaG9vdD9xPTAwMjYtMDAwMDAwMDE8L1JlY29tbWVuZERvYz4KPC9FcnJvcj4K" alt="" /></p>
</li>
</ul>
<div> <img src="/images_glob/git-command/rebase5.png" width="60%"> </div>
<p>查看日志：git log --oneline<br />
[<img src="data:application/xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEVycm9yPgogIDxDb2RlPk5vU3VjaEtleTwvQ29kZT4KICA8TWVzc2FnZT5UaGUgc3BlY2lmaWVkIGtleSBkb2VzIG5vdCBleGlzdC48L01lc3NhZ2U+CiAgPFJlcXVlc3RJZD42ODE0MjI2MjQ3OEFCMzM0MzRBQzdBNEU8L1JlcXVlc3RJZD4KICA8SG9zdElkPnVwaWMtb3NzLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbTwvSG9zdElkPgogIDxLZXk+YmxvZy9yZWJhc2U2LnBuZ2h0dHBzOi8vdXBpYy1vc3Mub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Jsb2cvcmViYXNlNi5wbmc8L0tleT4KICA8RUM+MDAyNi0wMDAwMDAwMTwvRUM+CiAgPFJlY29tbWVuZERvYz5odHRwczovL2FwaS5hbGl5dW4uY29tL3Ryb3VibGVzaG9vdD9xPTAwMjYtMDAwMDAwMDE8L1JlY29tbWVuZERvYz4KPC9FcnJvcj4K" alt="" /></p>
<h3 id="21-git-revert-ru-he-che-xiao-zhi-ding-de-ti-jiao-ni-jiu-shi-ba-zhe-ci-ti-jiao-hui-gun-dao-qi-qian-yi-ci-ti-jiao-de-zhuang-tai-dan-shi-you-bu-ying-xiang-qi-zhi-hou-de-ti-jiao">21.<code>git revert</code>: 如何撤销指定的提交呢，就是把这次提交回滚到其前一次提交的状态，但是又不影响其之后的提交？</h3>
<ul>
<li>
<p><code>git revert</code> 是回滚某个 commit ，不是回滚 “到” 某个</p>
</li>
<li>
<p><code>git revert</code>是用一次新的 commit 来回滚之前的 commit，<code>git reset</code>是直接删除指定的 commit。</p>
</li>
<li>
<p><code>git reset</code> 撤销到某次提交, <code>git revert</code> 撤销某次提交，撤销并不意味着删除本次提交，其 log 里仍然会有这次提交，只不过 revert 后会产生一个新的节点用于提交，而 reset 是会删除之前的 log。</p>
</li>
<li>
<p>需要回滚到上一个版本时，可以通过<code>git reset HEAD~1</code>实现，也可以通过执行<code>git revert HEAD</code>实现。区别就是 reset 后再次发布需要<code>git push -f</code>，而 revert 不需要 - f 参数，因为 revert 时会在顶端产生一个新的节点，其版本号一定比远端新的。</p>
</li>
<li>
<p>还有一点需要注意，例如 dev 是从 master checkout 出来的分支，然后针对 dev 执行 reset 时，如果 reset 的版本 master 里也包含，此时再将 dev merge 回 master 时，则 master 里会保留本应该被 reset 的内容，而执行 revert 则不会出现这个问题，因为 revert 是用一次逆向的 commit“中和” 之前的提交。</p>
</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git revert HEAD        
</span><span>git revert HEAD^       
</span><span>git revert HEAD~3      
</span><span>git revert commit号    
</span><span>
</span><span>
</span><span>git revert -n HEAD~3
</span><span>git revert -n &lt;commit1&gt;..&lt;commit2&gt;
</span></code></pre>
<h3 id="22-ru-he-da-tag">22. 如何打 tag</h3>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git tag -a &quot;prod_x.x.x&quot; -m &quot;message&quot; 
</span><span>git push origin &quot;prod_x.x.x&quot; 
</span><span>
</span><span>git tag 
</span><span>git show prod_x.x.x 
</span><span>
</span><span>git checkout -b hotfix_x.x.x prod_x.x.x 
</span><span>git push origin hotfix_x.x.x 
</span><span>git branch --set-upstream-to=origin/hotfix_x.x.x hotfix_x.x.x
</span></code></pre>
<h3 id="23-git-pull-git-fetch-git-mergezhe-chong-shuo-fa-dui-ma">23.<code>git pull</code> = <code>git fetch</code> + <code>git merge</code>这种说法对吗？</h3>
<ul>
<li>
<p>默认情况下，<code>git pull</code> = <code>git fetch</code> + <code>git merge</code></p>
</li>
<li>
<p>如果配置了 <code>pull.rebase=true</code>，那么 <code>git pull</code> 不再执行 <code>merge</code>，而是执行 <code>rebase</code>。</p>
</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git config --global pull.rebase true
</span><span>
</span><span>
</span><span>git config --global pull.rebase false
</span><span>
</span><span>
</span><span>
</span><span>git config --global pull.rebase
</span><span>
</span><span>git config pull.rebase
</span></code></pre>
<ul>
<li>其实更好的比较是<code>git pull --rebase</code> 与 <code>git fetch</code> + <code>git merge</code>的区别，其相当于<code>git fetch</code> + <code>git rebase</code></li>
</ul>
<p>为了说清楚这个问题，我们需要先明白 git 的三个仓库：</p>
<ol>
<li>
<p>本地仓库：如 master，修改代码，提交暂存区，然后 commit 到的就是本地仓库</p>
</li>
<li>
<p>本地远程跟踪仓库：如 orign/master，这个仓库不能用来直接提交代码，其用来保存上一次从远程仓库拉取到的最新版本，如果不主动执行 git fetch，git pull，git push 等，是不会更新这个版本的。</p>
</li>
<li>
<p>远程仓库：git 服务器，如 github。执行 git push 时会将本地仓库的版本发布到远程仓库。</p>
</li>
</ol>
<ul>
<li>
<p><code>git fetch</code>的作用是将远程仓库 (如 github)的版本与本地远程跟踪仓库 (如 orign/master) 的版本保持一致。之后我们在 master 分支下执行<code>git merge orign/master</code>就会将远程仓库的代码合并到本地仓库，所以合并后会产出一个新的版本，我们可以发布这个版本到远程仓库。</p>
</li>
<li>
<p><code>git pull</code>的作用是先执行<code>git fetch</code>，再执行<code>git merge</code>，所以<code>git pull</code>会自动将远程仓库的代码合并到本地仓库，所以合并后会产出一个新的版本，我们可以发布这个版本到远程仓库。</p>
</li>
</ul>
<h3 id="24-ru-he-que-ding-kai-fa-ce-shi-fa-bu-liu-cheng">24. 如何确定开发–&gt; 测试–&gt; 发布流程？</h3>
<h4 id="kai-fa-a-mo-xing-ji-yu-master-de-zhu-fen-zhi-kai-fa-mo-xing">开发 A 模型：基于 master 的主分支开发模型</h4>
<p>[<img src="data:application/xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEVycm9yPgogIDxDb2RlPk5vU3VjaEtleTwvQ29kZT4KICA8TWVzc2FnZT5UaGUgc3BlY2lmaWVkIGtleSBkb2VzIG5vdCBleGlzdC48L01lc3NhZ2U+CiAgPFJlcXVlc3RJZD42ODE0MjI2MjQ3OEFCMzM0MzREOTdBNEU8L1JlcXVlc3RJZD4KICA8SG9zdElkPnVwaWMtb3NzLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbTwvSG9zdElkPgogIDxLZXk+YmxvZy9BLWdpdC1kZXYucG5naHR0cHM6Ly91cGljLW9zcy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vYmxvZy9BLWdpdC1kZXYucG5nPC9LZXk+CiAgPEVDPjAwMjYtMDAwMDAwMDE8L0VDPgogIDxSZWNvbW1lbmREb2M+aHR0cHM6Ly9hcGkuYWxpeXVuLmNvbS90cm91Ymxlc2hvb3Q/cT0wMDI2LTAwMDAwMDAxPC9SZWNvbW1lbmREb2M+CjwvRXJyb3I+Cg==" alt="" /></p>
<ul>
<li>
<p>使用 git rebase orign 将远程分支内容合并到当前 master 主分支，保证本地 master 始终是一条线</p>
</li>
<li>
<p>模型结构简单，始终记住使用<code>git fetch</code> + <code>git rebase</code>或者<code>git pull --rebase</code>更新主分支版本</p>
</li>
</ul>
<h4 id="kai-fa-b-mo-xing-ji-yu-dev-de-zi-fen-zhi-kai-fa-mo-xing">开发 B 模型：基于 dev 的子分支开发模型</h4>
<p>[<img src="data:application/xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEVycm9yPgogIDxDb2RlPk5vU3VjaEtleTwvQ29kZT4KICA8TWVzc2FnZT5UaGUgc3BlY2lmaWVkIGtleSBkb2VzIG5vdCBleGlzdC48L01lc3NhZ2U+CiAgPFJlcXVlc3RJZD42ODE0MjI2MjQ3OEFCMzM0MzQwNTdCNEU8L1JlcXVlc3RJZD4KICA8SG9zdElkPnVwaWMtb3NzLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbTwvSG9zdElkPgogIDxLZXk+YmxvZy9CLWdpdC1kZXYucG5naHR0cHM6Ly91cGljLW9zcy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vYmxvZy9CLWdpdC1kZXYucG5nPC9LZXk+CiAgPEVDPjAwMjYtMDAwMDAwMDE8L0VDPgogIDxSZWNvbW1lbmREb2M+aHR0cHM6Ly9hcGkuYWxpeXVuLmNvbS90cm91Ymxlc2hvb3Q/cT0wMDI2LTAwMDAwMDAxPC9SZWNvbW1lbmREb2M+CjwvRXJyb3I+Cg==" alt="" /></p>
<ul>
<li>
<p>增加了一个 dev 子分支，合并回 master 主分支时可以通过<code>git rebase -i</code>的方式合并多个 commit 为一个 commit，减少版本号数量</p>
</li>
<li>
<p>每次开发时要创建新的分支，开发完成后删除该分支，虽略显反锁，但也更加灵活，比如上一次的开发任务还没有完成，有一个紧急的任务需要马上处理，此时只需要从 master 分支 checkout 出一个子分支进行开发即可。</p>
</li>
<li>
<p>使用<code>git pull --rebase</code>更新远程版本，使用<code>git rebase dev</code>合并子分支，总的目标依旧是保证本地 master 始终是一条线</p>
</li>
</ul>
<h4 id="ce-shi-mo-xing-ji-yu-a-b-mo-xing-de-master-de-zhu-fen-zhi">测试模型：基于 A\B 模型的 master 的主分支</h4>
<ul>
<li>
<p>开发完成后，从 master 分支中 checkout 出一个 release 分支用于测试</p>
</li>
<li>
<p>测试过程中如果有 bug，则由开发人员通过开发模型进行修复，修复后 merge 到 release 中</p>
</li>
<li>
<p>测试通过后，将 release 分支内容 merge 到 prod 分支中（prod 表示生产分支，第一次时从 release 中 checkout 创建）</p>
</li>
<li>
<p>release 分支仅仅为了本次发布内容而创建的测试分支，所以发布后可以删除 release 分支</p>
</li>
</ul>
<h4 id="fa-bu-mo-xing">发布模型</h4>
<ul>
<li>
<p>release 分支测试通过够会 merge 到 prod 生产分支，此时代码可以发布上线，上线前需要为 prod 打 tag</p>
</li>
<li>
<p>只有打了 tag 的代码才能部署上线，如果线上代码发现 bug，则从对应的 tag 中 checkout 一个 hotfix 分支，用于 bug 修复</p>
</li>
<li>
<p>bug 修复后从 hotfix 分支 checkout 出 hotfix_release 分支进行测试，测试过程按照<code>测试模型</code>进行</p>
</li>
<li>
<p>测试通过后按照<code>发布模型</code>进行</p>
</li>
<li>
<p>发布后需要将 hotfix_release 分支 merge 到 master 开发主分支，之后可以删除本次 hotfix 分支和 hotfix_release 分支</p>
</li>
</ul>
<h4 id="shuo-ming">说明</h4>
<ul>
<li>
<p>本地和远程始终存在的分支是 master 开发主分支和 prod 发布主分支</p>
</li>
<li>
<p>每次上线前一定要打 tag，tag 对应的就是当前生产环境</p>
</li>
<li>
<p>测试分支和修复分支根据需要进行创建，用后可以删除。</p>
</li>
</ul>
<h3 id="25-git-stash-wo-yi-jing-xiu-gai-liao-ben-di-de-dai-ma-dan-shi-huan-mei-you-commit-dan-shi-you-xiang-qie-dao-qi-ta-fen-zhi-bu-xiang-diu-qi-xiu-gai-ye-bu-xiang-ba-zhe-xie-xiu-gai-dai-dao-qi-ta-fen-zhi-yin-wei-dai-ma-huan-you-yong-dang-qie-hui-shi-huan-xu-yao-hui-fu-zhe-xie-xiu-gai-na-me-gai-zen-me-chu-li">25.<code>git stash</code>: 我已经修改了本地的代码，但是还没有 commit，但是又想切到其他分支，不想丢弃修改，也不想把这些修改带到其它分支，因为代码还有用，当切回时还需要恢复这些修改，那么该怎么处理？</h3>
<ul>
<li>
<p><code>git stash</code>可以做到这一点，其会将工作区中的更改（包括未暂存和已暂存的文件）保存到一个临时区域（称为 “stash 栈”），并将工作目录恢复为干净的状态。</p>
</li>
<li>
<p>其特点是非破坏性操作，改动不会丢失，可以随时取回，这在切换分支或处理紧急任务时非常有用。</p>
</li>
</ul>
<h4 id="chuang-jian-yi-ge-stash">创建一个 stash</h4>
<ul>
<li>
<p>将当前分支上所有未提交的更改（包括工作区和暂存区的内容）保存到 stash 栈中。</p>
</li>
<li>
<p>执行后，工作目录会变得干净（与最近的一次提交一致）。</p>
</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>$ git stash
</span><span>保存工作目录和索引状态 WIP on main: c4f0eaf 2024-12-05 11:43:57#brew
</span><span>
</span><span>
</span><span>$ git stash save &quot;描述信息&quot;
</span><span>保存工作目录和索引状态 On main: 描述信息
</span></code></pre>
<h4 id="cha-kan-stash">查看 stash</h4>
<ul>
<li>查看当前的 stash 栈，包括每个 stash 的编号、提交信息、日期和时间等。</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>$ git stash list
</span><span>stash@{0}: WIP on main: c4f0eaf 2024-12-05 11:43:57#brew
</span></code></pre>
<h4 id="hui-fu-stash">恢复 stash</h4>
<ul>
<li>
<p>从 stash 栈中恢复最近一次保存的 stash，但 不会删除 stash。</p>
</li>
<li>
<p>执行后，工作目录会恢复到 stash 保存的状态</p>
</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>$ git stash apply
</span><span>位于分支 main
</span><span>您的分支与上游分支 &#39;origin/main&#39; 一致。
</span><span>
</span><span>尚未暂存以备提交的变更：
</span><span>  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）
</span><span>  （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动）
</span><span>        修改：     source/_posts/git-command.md
</span><span>
</span><span>修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）
</span><span>
</span><span>
</span><span>$ git stash apply stash@{1}
</span></code></pre>
<h4 id="shan-chu-stash">删除 stash</h4>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>$ git stash drop
</span><span>丢弃了 refs/stash@{0}（6f483ee0c0753762a497d24f424c8998372e96a9）
</span><span>
</span><span>
</span><span>$ git stash drop stash@{1}
</span><span>丢弃了 stash@{1}（50a9e83d3bf96e2f3ca5368d2a248113874507b9）
</span><span>
</span><span>
</span><span>$ git stash clear
</span></code></pre>
<h4 id="hui-fu-bing-shan-chu-stash">恢复并删除 stash</h4>
<ul>
<li>等价于 <code>git stash apply</code> + <code>git stash drop</code></li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>$ git stash pop
</span><span>
</span><span>位于分支 main
</span><span>您的分支与上游分支 &#39;origin/main&#39; 一致。
</span><span>
</span><span>尚未暂存以备提交的变更：
</span><span>  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）
</span><span>  （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动）
</span><span>        修改：     source/_posts/git-command.md
</span><span>
</span><span>修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）
</span><span>丢弃了 refs/stash@{0}（63a7551a9bc920f82802cbda542da99800b8a58c）
</span></code></pre>
<h4 id="zhu-yi-shi-xiang">注意事项</h4>
<ul>
<li>如果有未追踪的文件，需要用 <code>git stash -u</code> 或 <code>git stash --include-untracked</code> 才会保存。</li>
</ul>
<h4 id="dian-xing-de-shi-yong-chang-jing">典型的使用场景</h4>
<ul>
<li>
<ol>
<li>假设当前分支有未完成的更改，但需要切换到其他分支紧急处理一些问题</li>
</ol>
</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git stash
</span><span>
</span><span>git checkout 其他分支
</span><span>
</span><span>git checkout 原分支
</span><span>
</span><span>git stash pop
</span></code></pre>
<ul>
<li>如果 stash 恢复时遇到冲突，比如文件被修改了，则需要手动解决冲突</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>$ git stash pop
</span><span>错误：您对下列文件的本地修改将被合并操作覆盖：
</span><span>        source/_posts/git-command.md
</span><span>请在合并前提交或贮藏您的修改。
</span><span>正在终止
</span><span>位于分支 main
</span><span>您的分支与上游分支 &#39;origin/main&#39; 一致。
</span><span>
</span><span>尚未暂存以备提交的变更：
</span><span>  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）
</span><span>  （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动）
</span><span>        修改：     source/_posts/git-command.md
</span><span>
</span><span>修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）
</span><span>贮藏条目被保留以备您再次需要。
</span><span>
</span><span>
</span><span>$ git add .
</span><span>
</span><span>
</span><span>
</span><span>$ git stash pop
</span><span>自动合并 source/_posts/git-command.md
</span><span>冲突（内容）：合并冲突于 source/_posts/git-command.md
</span><span>位于分支 main
</span><span>您的分支与上游分支 &#39;origin/main&#39; 一致。
</span><span>
</span><span>未合并的路径：
</span><span>  （使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存）
</span><span>  （使用 &quot;git add &lt;文件&gt;...&quot; 标记解决方案）
</span><span>        双方修改：   source/_posts/git-command.md
</span><span>
</span><span>修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）
</span><span>贮藏条目被保留以备您再次需要。
</span><span>
</span><span>
</span><span>$ git stash list
</span><span>stash@{0}: WIP on main: c4f0eaf 2024-12-05 11:43:57#brew
</span><span>
</span><span>
</span><span>$ git stash drop
</span></code></pre>
<ul>
<li>
<ol start="2">
<li>本地修改了部分文件，但此时需要更新远程仓库，此时需要先将本地修改的文件暂存，再更新远程仓库，最后再恢复本地修改的文件。</li>
</ol>
</li>
</ul>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>git pull --rebase --autostash
</span></code></pre>

        </div>

        
            <div class="pagination">
                <div class="pagination__title">
                    <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                    <hr />
                </div>
                <div class="pagination__buttons">
                        <span class="button previous">
                            <a href="https://widowmaker2025.github.io/vimbian-ji-qi-zhuan-zai/">
                                <span class="button__icon">←</span>&nbsp;
                                <span class="button__text">Vim编辑器</span>
                            </a>
                        </span>
                    
                    </div>
            </div>
        
            
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/waline/3.3.2/waline.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Comment Below</span>
        <hr />
    </div>
</div>
<div id="waline-comment"></div>
<script>
if (!window.initWaline) window.initWaline = () => {
        if (!document.getElementById('waline-comment')) return
        import('https://cdnjs.cloudflare.com/ajax/libs/waline/3.3.2/waline.min.js').then(({ init }) => init({
            el: '#waline-comment',
            serverURL: 'https://waline-comment.woodwhale.cn',
            lang: 'zh-CN',
            locale: {
                placeholder: '让我们说中文!',
                sofa: '暂无评论',
            },
            search: false,
            pageview: false,
            comment: false,
            reaction: false,
            emoji: [
                'https://unpkg.com/@waline/emojis@1.2.0/tieba',
            ],
            dark: 'auto',
        }))
    }
document.addEventListener('DOMContentLoaded', window.initWaline)
document.addEventListener('pjax:complete', window.initWaline)
</script>

        </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2025
 Rocky.houjinsong</span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
        
<script>
document.addEventListener('DOMContentLoaded', () => {
    if (window.pjax) return
    window.pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox]):not([onclick="return false;"]):not([onclick="return!1"]):not([target="_blank"]):not([target="view_window"]):not([href$=".xml"])',
        selectors: [
            "head title",
            "head meta[name=keywords]",
            "head meta[name=description]", 
            ".menu__inner",
            ".content",
        ],
        cacheBust: false,
        timeout: 6000,
    })
})
</script>

    </footer>
    

</div>
</body>

</html>